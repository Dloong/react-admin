'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var classNames = _interopDefault(require('classnames'));
var bizcharts = require('bizcharts');
var dataSet = require('@antv/data-set');
var FitText = _interopDefault(require('rc-fit-text'));
var aweUtils = require('awe-utils');
var moment = _interopDefault(require('moment'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = "/* stylelint-disable at-rule-empty-line-before,at-rule-name-space-after,at-rule-no-unknown */\n/* stylelint-disable no-duplicate-selectors */\n/* stylelint-disable */\n/* stylelint-disable declaration-bang-space-before,no-duplicate-selectors,string-no-newline */\n.rc-pie-chart {\n  position: relative;\n}\n.rc-pie-chart__chart {\n  position: relative;\n}\n.rc-pie-chart.show-legend .rc-pie-chart__chart {\n  width: 50%;\n}\n.rc-pie-chart__legend {\n  position: absolute;\n  top: 50%;\n  right: 0;\n  width: 50%;\n  margin-left: 15px;\n  padding: 0;\n  list-style: none;\n  -webkit-transform: translateY(-50%);\n          transform: translateY(-50%);\n}\n.rc-pie-chart__legend li {\n  position: relative;\n  display: -webkit-box;\n  display: flex;\n  height: 22px;\n  padding: 12px 0;\n  margin-bottom: 16px;\n  line-height: 22px;\n  border-bottom: 1px solid #dfdfdf;\n  cursor: pointer;\n  -webkit-box-align: center;\n          align-items: center;\n}\n.rc-pie-chart__legend li:last-child {\n  margin-bottom: 0;\n}\n.rc-pie-chart__legend li > div {\n  width: 33%;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.rc-pie-chart__legend .dot {\n  position: relative;\n  top: -1px;\n  display: inline-block;\n  width: 8px;\n  height: 8px;\n  margin-right: 8px;\n  border-radius: 8px;\n}\n.rc-pie-chart__legend .title {\n  color: rgba(0, 0, 0, 0.65);\n}\n.rc-pie-chart__legend .percent {\n  text-align: right;\n  color: rgba(0, 0, 0, 0.45);\n}\n.rc-pie-chart__legend .value {\n  text-align: right;\n}\n.rc-pie-chart__content {\n  position: absolute;\n  display: -webkit-box;\n  display: flex;\n  top: 50%;\n  left: 50%;\n  max-height: 62px;\n  text-align: center;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-box-align: center;\n          align-items: center;\n  -webkit-box-pack: center;\n          justify-content: center;\n}\n.rc-pie-chart__content h4 {\n  height: 22px;\n  margin-bottom: 8px;\n  color: rgba(0, 0, 0, 0.45);\n  font-weight: normal;\n  line-height: 22px;\n}\n.rc-pie-chart__content h5 {\n  margin: 0;\n  color: #8a8a8a;\n  font-weight: normal;\n}\n.rc-pie-chart__content p {\n  margin: 0;\n  padding: 0;\n  color: rgba(0, 0, 0, 0.85);\n  white-space: nowrap;\n}\n";
styleInject(css);

var scale = {
  x: {
    type: 'cat',
    range: [0, 1]
  },
  y: {
    min: 0
  }
};
var defaultScale = {
  x: {
    type: 'cat',
    range: [0, 1]
  },
  y: {
    min: 0
  }
};

var PieChart = function PieChart(props) {
  var _classNames;

  var chartInstance = null;
  var requestRef = null;
  var prefixCls = 'rc-pie-chart';
  var rootRef = React.useRef(null);
  var className = props.className,
      style = props.style,
      type = props.type,
      height = props.height,
      forceFit = props.forceFit,
      padding = props.padding,
      animate = props.animate,
      percent = props.percent,
      color = props.color,
      colors = props.colors,
      title = props.title,
      subTitle = props.subTitle,
      hasLegend = props.hasLegend,
      valueFormat = props.valueFormat,
      label = props.label,
      showLabel = props.showLabel,
      total = props.total,
      autoTotal = props.autoTotal,
      radius = props.radius,
      legend = props.legend,
      innerRadius = props.innerRadius,
      lineWidth = props.lineWidth,
      onGetG2Instance = props.onGetG2Instance;

  var _React$useState = React.useState(0),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      innerWidth = _React$useState2[0],
      setInnerWidth = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      legendBlock = _React$useState4[0],
      setLegendBlock = _React$useState4[1];

  var _React$useState5 = React.useState([]),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      legendData = _React$useState6[0],
      setLegendData = _React$useState6[1];

  var _React$useState7 = React.useState(0),
      _React$useState8 = _slicedToArray(_React$useState7, 2),
      totalNumber = _React$useState8[0],
      setTotalNumber = _React$useState8[1];

  React.useEffect(function () {
    window.addEventListener('resize', function () {
      requestRef = requestAnimationFrame(function () {
        return resize();
      });
    }, {
      passive: true
    });
  }, []);
  React.useEffect(function () {
    var newTotal = 0;

    if (autoTotal) {
      data.forEach(function (item) {
        if (item.y) {
          newTotal += item.y;
        }
      });
    } else {
      newTotal = typeof total === 'function' ? total() : total;
    }

    setTotalNumber(newTotal);
  }, [props.total, props.autoTotal, props.data]);
  React.useEffect(function () {
    getLegendData();
  }, [props.data]); // 用于自定义图例

  var getLegendData = function getLegendData() {
    if (!chartInstance) return;
    var geom = chartInstance.getAllGeoms()[0];
    if (!geom) return; // @ts-ignore

    var items = geom.get('dataArray') || [];
    var data = items.map(function (item) {
      var origin = item[0]._origin;
      origin.color = item[0].color;
      origin.checked = true;
      return origin;
    });
    setLegendData(data);
  };

  var handleLegendClick = function handleLegendClick(item, i) {
    var newItem = item;
    newItem.checked = !newItem.checked;

    var newLegendData = _toConsumableArray(legendData);

    newLegendData[i] = newItem;
    var filteredLegendData = newLegendData.filter(function (l) {
      return l.checked;
    }).map(function (l) {
      return l.x;
    });

    if (chartInstance) {
      chartInstance.filter('x', function (val) {
        return filteredLegendData.indexOf(val + '') > -1;
      });
    }

    setLegendData(newLegendData);
  };

  var resize = function resize() {
    var root = rootRef.current;

    if (!hasLegend || !root) {
      window.removeEventListener('resize', resize);
      return;
    }

    if (root && root.parentNode && root.parentNode.clientWidth <= 380) {
      if (!legendBlock) {
        setLegendBlock(true);
      }
    } else {
      setLegendBlock(false);
    }
  };

  var handleGetG2Instance = function handleGetG2Instance(chart) {
    chartInstance = chart;
    setInnerWidth(chart.get('height') * innerRadius);
    onGetG2Instance && onGetG2Instance(chart);
  };

  var tooltipFormat = ['x*percent', function (x, p) {
    return {
      name: x,
      value: "".concat((p * 100).toFixed(2), "%")
    };
  }];
  var defaultColors = colors;
  var formatColor;
  var data = props.data || [];
  var tooltip = props.tooltip;
  var selected = props.selected;

  if (percent || percent === 0) {
    selected = false;
    tooltip = false;

    formatColor = function formatColor(value) {
      if (value === '占比') {
        return color || 'rgba(24, 144, 255, 0.85)';
      }

      return '#F0F2F5';
    };

    data = [{
      x: '占比',
      y: parseFloat(percent + '')
    }, {
      x: '反比',
      y: 100 - parseFloat(percent + '')
    }];
  }

  var dv = new dataSet.DataView();
  dv.source(data).transform({
    type: 'percent',
    field: 'y',
    dimension: 'x',
    as: 'percent'
  });
  var cols = Object.assign({}, defaultScale, scale);
  return React.createElement("div", {
    className: classNames(className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls), true), _defineProperty(_classNames, "show-legend", !!hasLegend), _defineProperty(_classNames, 'legend-block', legendBlock), _classNames)),
    ref: rootRef,
    style: style
  }, React.createElement("div", {
    className: "".concat(prefixCls, "__chart")
  }, React.createElement(bizcharts.Chart, {
    scale: type === 'theta' ? cols : undefined,
    height: height,
    forceFit: forceFit,
    data: dv,
    padding: padding,
    animate: animate,
    onGetG2Instance: handleGetG2Instance
  }, !!tooltip && React.createElement(bizcharts.Tooltip, {
    showTitle: false
  }), React.createElement(bizcharts.Coord, {
    type: type,
    radius: radius,
    innerRadius: innerRadius
  }), React.createElement(bizcharts.Legend, Object.assign({}, legend)), React.createElement(bizcharts.Geom, {
    style: {
      lineWidth: lineWidth,
      stroke: '#fff'
    },
    tooltip: tooltip ? tooltipFormat : undefined,
    type: type === 'theta' ? 'intervalStack' : 'interval',
    position: type === 'theta' ? 'percent' : 'x*percent',
    color: ['x', percent || percent === 0 ? formatColor : defaultColors],
    selected: selected
  }, showLabel && React.createElement(bizcharts.Label, Object.assign({
    content: 'percent'
  }, label)))), React.createElement(FitText, null, React.createElement("div", {
    className: "".concat(prefixCls, "__content"),
    style: {
      marginTop: legend && legend.visible ? -innerWidth * 0.1 : 0,
      width: innerWidth,
      height: +innerWidth,
      padding: innerWidth * 0.1
    }
  }, React.createElement("div", null, title && React.createElement("h4", null, title), (total || autoTotal) && React.createElement("p", null, totalNumber), subTitle && React.createElement("h5", null, subTitle))))), hasLegend && React.createElement("ul", {
    className: "".concat(prefixCls, "__legend")
  }, legendData.map(function (item, i) {
    return React.createElement("li", {
      key: item.x,
      onClick: function onClick() {
        return handleLegendClick(item, i);
      }
    }, React.createElement("div", {
      className: "title"
    }, React.createElement("span", {
      className: "dot",
      style: {
        backgroundColor: !item.checked ? '#aaa' : item.color
      }
    }), React.createElement("span", null, item.x)), React.createElement("div", {
      className: "value"
    }, React.createElement("span", {
      className: "value"
    }, valueFormat ? valueFormat(item.y) : item.y)), React.createElement("div", {
      className: "percent"
    }, React.createElement("span", {
      className: "percent"
    }, "".concat((Number.isNaN(item.percent) ? 0 : item.percent * 100).toFixed(2), "%"))));
  })));
};

PieChart.defaultProps = {
  type: 'theta',
  animate: true,
  forceFit: true,
  hasLegend: false,
  showLabel: false,
  height: 400,
  radius: 1,
  innerRadius: 0,
  lineWidth: 1,
  legend: {
    visible: false
  },
  data: [],
  padding: 'auto',
  autoTotal: false
};

var prefixCls = 'rc-line-chart';

var LineChart = function LineChart(props) {
  var className = props.className,
      style = props.style,
      title = props.title,
      height = props.height,
      padding = props.padding,
      titleMap = props.titleMap,
      legend = props.legend,
      colors = props.colors,
      smooth = props.smooth,
      borderWidth = props.borderWidth,
      sourceData = props.data;

  var _React$useState = React.useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      chartData = _React$useState2[0],
      setChartData = _React$useState2[1];

  var data = aweUtils.isArray(sourceData) ? sourceData : [];
  React.useEffect(function () {
    if (aweUtils.isArray(sourceData)) {
      var item = sourceData[0];
      if (!item) return;
      var newKeys = Object.keys(item).filter(function (item) {
        return item !== 'x';
      });
      var dv = new dataSet.DataView();
      dv.source(data).transform({
        type: 'map',
        callback: function callback(row) {
          var newRow = _objectSpread({}, row);

          newKeys.forEach(function (item) {
            newRow[titleMap[item]] = row[item];
          });
          return newRow;
        }
      }).transform({
        type: 'fold',
        fields: newKeys.map(function (item) {
          return titleMap[item];
        }),
        key: 'key',
        value: 'value'
      });
      setChartData(dv);
    }
  }, [props.data]);
  var cols = {
    x: {
      type: 'linear',
      tickInterval: 50
    }
  };
  return React.createElement("div", {
    className: classNames(className, _defineProperty({}, "".concat(prefixCls), true)),
    style: style
  }, title && React.createElement("h4", null, title), React.createElement(bizcharts.Chart, {
    height: height,
    padding: padding,
    data: chartData,
    scale: cols,
    forceFit: true
  }, React.createElement(bizcharts.Axis, {
    key: "axis-x",
    name: "x"
  }), React.createElement(bizcharts.Axis, {
    key: "axis-y",
    name: "value"
  }), React.createElement(bizcharts.Tooltip, null), React.createElement(bizcharts.Legend, Object.assign({
    position: "top"
  }, legend)), React.createElement(bizcharts.Geom, {
    type: "line",
    position: "x*value",
    size: borderWidth,
    color: colors ? ['key', colors] : 'key',
    shape: smooth ? 'smooth' : ''
  }), React.createElement(bizcharts.Geom, {
    type: "point",
    position: "x*value",
    size: 4,
    shape: "circle",
    style: {
      stroke: "#fff",
      lineWidth: 1
    }
  })));
};

LineChart.defaultProps = {
  height: 400,
  borderWidth: 2,
  padding: [60, 20, 40, 40],
  titleMap: {},
  smooth: false
};

var css$1 = "/* stylelint-disable at-rule-empty-line-before,at-rule-name-space-after,at-rule-no-unknown */\n/* stylelint-disable no-duplicate-selectors */\n/* stylelint-disable */\n/* stylelint-disable declaration-bang-space-before,no-duplicate-selectors,string-no-newline */\n.rc-chart-title {\n  position: relative;\n  margin-bottom: 20px;\n}\n.rc-chart-title.is-left {\n  text-align: left;\n}\n.rc-chart-title.is-center {\n  text-align: center;\n}\n.rc-chart-title.is-right {\n  text-align: right;\n}\n";
styleInject(css$1);

var Title = function Title(props) {
  var prefixCls = 'rc-chart-title';
  var className = props.className,
      text = props.text,
      position = props.position;

  if (text) {
    var _classNames;

    return React.createElement("div", {
      className: classNames(className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls), true), _defineProperty(_classNames, "is-left", position === 'left'), _defineProperty(_classNames, "is-right", position === 'right'), _defineProperty(_classNames, "is-center", position === 'center'), _classNames))
    }, React.createElement("h4", null, text));
  } else {
    return null;
  }
};

Title.defaultProps = {
  position: 'left'
};

var prefixCls$1 = 'rc-bar-chart';

var BarChart = function BarChart(props) {
  var className = props.className,
      type = props.type,
      scale = props.scale,
      style = props.style,
      title = props.title,
      titlePosition = props.titlePosition,
      height = props.height,
      xAxis = props.xAxis,
      yAxis = props.yAxis,
      mini = props.mini,
      colors = props.colors,
      label = props.label,
      tooltip = props.tooltip,
      showLabel = props.showLabel,
      legend = props.legend,
      padding = props.padding,
      direction = props.direction,
      titleMap = props.titleMap,
      borderWidth = props.borderWidth,
      sourceData = props.data;

  var _React$useState = React.useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      chartData = _React$useState2[0],
      setChartData = _React$useState2[1];

  var data = aweUtils.isArray(sourceData) ? sourceData : [];
  React.useEffect(function () {
    if (aweUtils.isArray(sourceData)) {
      var item = sourceData[0];
      if (!item) return;
      var newKeys = Object.keys(item).filter(function (item) {
        return item !== 'x';
      });
      var dv = new dataSet.DataView();
      dv.source(data).transform({
        type: 'map',
        callback: function callback(row) {
          var newRow = _objectSpread({}, row);

          newKeys.forEach(function (item) {
            newRow[titleMap[item]] = row[item];
          });
          return newRow;
        }
      }).transform({
        type: 'fold',
        fields: newKeys.map(function (item) {
          return titleMap[item];
        }),
        key: 'key',
        value: 'value'
      });
      setChartData(dv);
    }
  }, [props.data]);
  return React.createElement("div", {
    className: classNames(className, _defineProperty({}, "".concat(prefixCls$1), true)),
    style: style
  }, React.createElement(Title, {
    text: title,
    position: titlePosition
  }), React.createElement(bizcharts.Chart, {
    height: height,
    padding: padding,
    data: chartData,
    scale: scale,
    forceFit: true
  }, !mini && React.createElement(bizcharts.Axis, Object.assign({
    key: "axis-x",
    name: "x"
  }, xAxis)), !mini && React.createElement(bizcharts.Axis, Object.assign({
    key: "axis-y",
    name: "value"
  }, yAxis)), !mini && React.createElement(bizcharts.Legend, Object.assign({
    name: "key",
    position: "top"
  }, legend)), React.createElement(bizcharts.Coord, {
    transpose: direction === 'horizontal'
  }), React.createElement(bizcharts.Tooltip, Object.assign({}, tooltip)), React.createElement(bizcharts.Geom, {
    type: type,
    position: "x*value",
    color: colors ? ['key', colors] : 'key',
    size: borderWidth ? borderWidth : undefined
  }, showLabel && type === 'interval' && React.createElement(bizcharts.Label, Object.assign({
    content: ['key*value', function (name, value) {
      return value;
    }]
  }, label)))));
};

BarChart.defaultProps = {
  height: 400,
  type: 'interval',
  direction: 'vertical',
  titlePosition: 'left',
  titleMap: {},
  mini: false,
  showLabel: false,
  padding: 'auto'
};

var css$2 = "/* stylelint-disable at-rule-empty-line-before,at-rule-name-space-after,at-rule-no-unknown */\n/* stylelint-disable no-duplicate-selectors */\n/* stylelint-disable */\n/* stylelint-disable declaration-bang-space-before,no-duplicate-selectors,string-no-newline */\n.rc-area-chart {\n  position: relative;\n}\n";
styleInject(css$2);

var prefixCls$2 = 'rc-area-chart';

var AreaChart = function AreaChart(props) {
  var className = props.className,
      title = props.title,
      titlePosition = props.titlePosition,
      isStack = props.isStack,
      style = props.style,
      animate = props.animate,
      forceFit = props.forceFit,
      height = props.height,
      scale = props.scale,
      xAxis = props.xAxis,
      yAxis = props.yAxis,
      legend = props.legend,
      colors = props.colors,
      line = props.line,
      point = props.point,
      tooltip = props.tooltip,
      titleMap = props.titleMap,
      smooth = props.smooth,
      mini = props.mini,
      padding = props.padding,
      borderWidth = props.borderWidth,
      sourceData = props.data;

  var _React$useState = React.useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      chartData = _React$useState2[0],
      setChartData = _React$useState2[1];

  var _React$useState3 = React.useState({}),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      cols = _React$useState4[0],
      setCols = _React$useState4[1];

  var data = aweUtils.isArray(sourceData) ? sourceData : [];
  React.useEffect(function () {
    setCols(scale);
  }, [props.scale]);
  React.useEffect(function () {
    if (aweUtils.isArray(data)) {
      var item = data[0];
      if (!item) return;
      var newKeys = Object.keys(item).filter(function (item) {
        return item !== 'x';
      });
      var dv = new dataSet.DataView();
      dv.source(sourceData).transform({
        type: 'map',
        callback: function callback(row) {
          var newRow = _objectSpread({}, row);

          newKeys.forEach(function (item) {
            newRow[titleMap[item] || item] = row[item];
          });
          return newRow;
        }
      }).transform({
        type: 'fold',
        fields: newKeys.map(function (item) {
          return titleMap[item] || item;
        }),
        key: 'key',
        value: 'value'
      });
      setChartData(dv);
    }
  }, [props.data]);
  return React.createElement("div", {
    className: classNames(className, _defineProperty({}, "".concat(prefixCls$2), true)),
    style: style
  }, React.createElement(Title, {
    position: titlePosition,
    text: title
  }), React.createElement(bizcharts.Chart, {
    height: height,
    data: chartData,
    scale: cols,
    padding: padding,
    animate: animate,
    forceFit: forceFit
  }, !mini && React.createElement(bizcharts.Axis, Object.assign({
    name: "x",
    title: true
  }, xAxis)), !mini && React.createElement(bizcharts.Axis, Object.assign({
    name: "value",
    title: true
  }, yAxis)), !mini && React.createElement(bizcharts.Legend, Object.assign({}, legend)), React.createElement(bizcharts.Tooltip, Object.assign({}, tooltip)), React.createElement(bizcharts.Geom, {
    type: isStack ? 'areaStack' : 'area',
    position: "x*value",
    color: colors && colors.length ? ['key', colors] : 'key',
    shape: smooth ? 'smooth' : ''
  }), line && React.createElement(bizcharts.Geom, {
    type: isStack ? 'areaStack' : 'area',
    position: "x*value",
    size: borderWidth,
    color: colors && colors.length ? ['key', colors] : 'key',
    shape: smooth ? 'smooth' : ''
  }), point && React.createElement(bizcharts.Geom, {
    type: "point",
    position: "x*value",
    size: 4,
    shape: "circle",
    color: colors && colors.length ? ['key', colors] : 'key',
    style: {}
  })));
};

AreaChart.defaultProps = {
  height: 400,
  line: true,
  animate: true,
  forceFit: true,
  borderWidth: 2,
  scale: {},
  titleMap: {},
  data: [],
  isStack: false,
  mini: false,
  padding: 'auto'
};

var Months = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'];
/**
 * 解析时间范围
 * @param range
 *
 * 某一年
 * range: '2017'
 *
 * 某个月
 * range: '2017-02'
 *
 * 某个区间 可以月、天为单位 不能超过一年
 * range: ['2017-01-02', '2017-02-23']
 * range: ['2017-01', '2017-02']
 */

function getDateRange(range) {
  var startDate;
  var endDate;

  if (typeof range === 'string') {
    var date = moment(range, ['YYYY', 'YYYY-MM']);
    var times = range.split('-'); // 某一年

    if (times.length === 1) {
      startDate = date.startOf('year');
      endDate = moment(date).endOf('year');
    } // 某个月
    else {
        startDate = date.startOf('month');
        endDate = moment(date).endOf('month');
      }
  }

  if (Array.isArray(range) && range.length === 2) {
    var start = range[0];
    var end = range[1];
    var startTime = moment(start, ['YYYY-MM-DD', 'YYYY-MM']);
    var endTime = moment(end, ['YYYY-MM-DD', 'YYYY-MM']);

    if (startTime > endTime) {
      var _ref = [endTime, startTime];
      startTime = _ref[0];
      endTime = _ref[1];
    }

    var starTimes = start.split('-');

    if (starTimes.length === 2) {
      startDate = startTime.startOf('month');
    } else {
      startDate = moment(startTime);
    }

    var endTimes = end.split('-');

    if (endTimes.length === 2) {
      endDate = endTime.endOf('month');
    } else {
      endDate = endTime;
    }
  }

  return [startDate, endDate];
} // 获取间隔的所有日期

function getVirtualDate(range) {
  var dates = [];
  var newRange = getDateRange(range);

  if (newRange && newRange.length === 2) {
    var endTime = newRange[1].unix();
    var currentDate = newRange[0];

    while (currentDate.unix() <= endTime) {
      dates.push(currentDate.format('YYYY-MM-DD'));
      currentDate = currentDate.add(1, 'day');
    }
  }

  return dates;
}
/**
 * 获取chart数据
 * @param range
 * @param data
 * @param weekStart
 */

function getChartData(range) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var weekStart = arguments.length > 2 ? arguments[2] : undefined;
  var result = {
    data: [],
    months: []
  };
  var weeks = [0];
  var dates = getVirtualDate(range);

  if (dates && dates.length) {
    // 求取需要展示的月份
    var startMonth = moment(dates[0]).month();
    var endMonth = moment(dates[dates.length - 1]).month();
    result.months = getMonths(startMonth, endMonth);
    result.data = dates.map(function (item, index) {
      var current = moment(item);
      var weekday = current.weekday();

      if (weekStart === 1) {
        weekday = current.weekday() === 0 ? 7 : current.weekday();
        weekday = weekday - 1;
      }

      if (weekday === 0 && index !== 0) {
        weeks.push(weeks[weeks.length - 1] + 1);
      }

      return {
        date: item,
        week: weeks[weeks.length - 1],
        value: data[item] || 0,
        // 周几
        day: weekday,
        month: current.month()
      };
    });
  }

  return result;
} // 获取设置范围所有的月份

function getMonths(startMonth, endMonth) {
  var months = [];

  if (startMonth < endMonth) {
    for (var i = startMonth; i <= endMonth; i++) {
      months.push(i);
    }
  } else {
    for (var _i = startMonth; _i <= 11; _i++) {
      months.push(_i);
    }

    for (var _i2 = 0; _i2 <= endMonth; _i2++) {
      months.push(_i2);
    }
  }

  return months.map(function (item) {
    return Months[item];
  });
}

var defaultCols = {
  day: {
    type: 'cat',
    values: []
  },
  week: {
    type: 'cat'
  },
  commits: {
    sync: true
  }
};
var Calendar = function Calendar(props) {
  var scale = props.scale,
      range = props.range,
      data = props.data,
      animate = props.animate,
      colors = props.colors,
      height = props.height,
      weekAxis = props.weekAxis,
      dayAxis = props.dayAxis,
      padding = props.padding,
      forceFit = props.forceFit,
      weekStart = props.weekStart,
      borderWidth = props.borderWidth;

  var _React$useState = React.useState([]),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      chartData = _React$useState2[0],
      setChartData = _React$useState2[1];

  var _React$useState3 = React.useState([]),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      months = _React$useState4[0],
      setMonths = _React$useState4[1];

  var _React$useState5 = React.useState(defaultCols),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      cols = _React$useState6[0],
      setCols = _React$useState6[1];

  if (weekStart === 1) {
    defaultCols.day.values = ['周一', '周二', '周三', '周四', '周五', '周六', '周日'];
  } else {
    defaultCols.day.values = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
  }

  React.useEffect(function () {
    var result = getChartData(range, data, weekStart);
    setChartData(result.data);
    setMonths(result.months);
  }, [props.range, props.data]);
  React.useEffect(function () {
    if (!scale) return;
    setCols(Object.assign({}, defaultCols, scale));
  }, [props.scale, props.weekStart]);
  bizcharts.Shape.registerShape('polygon', 'boundary-polygon', {
    draw: function draw(cfg, container) {
      if (!bizcharts.Util.isEmpty(cfg.points)) {
        var attrs = {
          stroke: '#fff',
          lineWidth: borderWidth,
          fill: cfg.color,
          fillOpacity: cfg.opacity
        };
        var points = cfg.points;
        var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']];
        attrs['path'] = this.parsePath(path);
        var polygon = container.addShape('path', {
          attrs: attrs
        });
        container.sort();
        return polygon;
      }
    }
  });
  return React.createElement("div", null, React.createElement(bizcharts.Chart, {
    height: height,
    data: chartData,
    scale: cols,
    animate: animate,
    padding: padding,
    forceFit: forceFit
  }, React.createElement(bizcharts.Tooltip, {
    title: 'date'
  }), React.createElement(bizcharts.Axis, Object.assign({
    name: "week",
    position: "bottom",
    tickLine: null,
    line: null,
    label: {
      offset: 12,
      textStyle: {
        fontSize: 12,
        fill: '#666',
        textBaseline: 'top'
      },
      formatter: function formatter(val) {
        if (val === '2') {
          return months[0];
        } else if (val === '6') {
          return months[1];
        } else if (val === '10') {
          return months[2];
        } else if (val === '15') {
          return months[3];
        } else if (val === '19') {
          return months[4];
        } else if (val === '24') {
          return months[5];
        } else if (val === '28') {
          return months[6];
        } else if (val === '33') {
          return months[7];
        } else if (val === '37') {
          return months[8];
        } else if (val === '42') {
          return months[9];
        } else if (val === '46') {
          return months[10];
        } else if (val === '51') {
          return months[11];
        }

        return '';
      }
    }
  }, weekAxis)), React.createElement(bizcharts.Axis, Object.assign({
    name: 'day'
  }, dayAxis)), React.createElement(bizcharts.Geom, {
    type: "polygon",
    position: 'week*day*date',
    shape: "boundary-polygon",
    color: colors ? ['value', colors] : 'value'
  }), React.createElement(bizcharts.Coord, {
    reflect: 'y'
  })));
};
Calendar.defaultProps = {
  height: 400,
  animate: true,
  forceFit: true,
  borderWidth: 2,
  weekStart: 1,
  data: {}
};

var prefixCls$3 = 'rc-line-chart';

var RadarChart = function RadarChart(props) {
  var className = props.className,
      style = props.style,
      title = props.title,
      sourceData = props.data,
      height = props.height,
      titleMap = props.titleMap,
      borderWidth = props.borderWidth,
      cols = props.cols,
      colors = props.colors,
      radius = props.radius,
      xAxis = props.xAxis,
      yAxis = props.yAxis,
      areas = props.areas,
      padding = props.padding;

  var _React$useState = React.useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      chartData = _React$useState2[0],
      setChartData = _React$useState2[1];

  var data = aweUtils.isArray(sourceData) ? sourceData : [];
  React.useEffect(function () {
    if (aweUtils.isArray(sourceData)) {
      var item = sourceData[0];
      if (!item) return;
      var newKeys = Object.keys(item).filter(function (item) {
        return item !== 'x';
      });
      var dv = new dataSet.DataView();
      dv.source(data).transform({
        type: 'map',
        callback: function callback(row) {
          var newRow = _objectSpread({}, row);

          newKeys.forEach(function (item) {
            newRow[titleMap[item]] = row[item];
          });
          return newRow;
        }
      }).transform({
        type: 'fold',
        fields: newKeys.map(function (item) {
          return titleMap[item];
        }),
        key: 'key',
        value: 'value'
      });
      setChartData(dv);
    }
  }, [props.data]);
  return React.createElement("div", {
    className: classNames(className, _defineProperty({}, "".concat(prefixCls$3), true)),
    style: style
  }, title && React.createElement("h4", null, title), React.createElement(bizcharts.Chart, {
    height: height,
    padding: padding,
    data: chartData,
    scale: cols,
    forceFit: true
  }, React.createElement(bizcharts.Coord, {
    type: "polar",
    radius: radius
  }), React.createElement(bizcharts.Tooltip, null), React.createElement(bizcharts.Legend, null), React.createElement(bizcharts.Axis, Object.assign({
    key: "axis-x",
    name: 'x',
    line: null,
    tickLine: null,
    grid: {
      lineStyle: {
        lineDash: null
      },
      hideFirstLine: false
    }
  }, xAxis)), React.createElement(bizcharts.Axis, Object.assign({
    key: "axis-y",
    name: 'value',
    line: null,
    tickLine: null,
    grid: {
      type: 'polygon',
      lineStyle: {
        lineDash: null
      },
      alternateColor: "rgba(0, 0, 0, 0.04)"
    }
  }, yAxis)), React.createElement(bizcharts.Geom, {
    type: 'line',
    position: 'x*value',
    size: borderWidth,
    color: colors.length ? ['key', colors] : 'key'
  }), React.createElement(bizcharts.Geom, {
    type: 'point',
    position: 'x*value',
    size: 4,
    shape: 'circle',
    color: colors.length ? ['key', colors] : 'key'
  }), areas ? React.createElement(bizcharts.Geom, {
    type: 'area',
    position: 'x*value',
    color: colors.length ? ['key', colors] : 'key'
  }) : ''));
};

RadarChart.defaultProps = {
  height: 400,
  borderWidth: 2,
  titleMap: {},
  data: [],
  colors: [],
  radius: 1,
  xAxis: {},
  yAxis: {},
  areas: true,
  padding: 'auto'
};

var prefixCls$4 = 'rc-line-chart';

var BoxChart = function BoxChart(props) {
  var className = props.className,
      style = props.style,
      data = props.data,
      height = props.height,
      colors = props.colors,
      borderWidth = props.borderWidth,
      valueSection = props.valueSection,
      outlierColor = props.outlierColor,
      xAxis = props.xAxis,
      yAxis = props.yAxis,
      legend = props.legend,
      tooltip = props.tooltip,
      padding = props.padding,
      title = props.title; // has `outliers` property ?

  var outliersFlag = false;
  data.map(function (item, index) {
    if (item.hasOwnProperty("outliers")) {
      outliersFlag = true;
    }

    return index;
  }); // 颜色区间

  var colorMap = {};
  data.map(function (item, index) {
    if (item.hasOwnProperty("x") && colorMap[item["x"]] === undefined) {
      colorMap[item["x"]] = colors[Object.keys(colorMap).length];
    }

    return index;
  }); // scale sols

  var cols = {};

  if (valueSection && valueSection.length > 1) {
    cols["bin"] = {
      min: valueSection[0],
      max: valueSection[1]
    };
    cols["outliers"] = {
      min: valueSection[0],
      max: valueSection[1]
    };
  } // dv


  var _React$useState = React.useState([]),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      chartData = _React$useState2[0],
      setChartData = _React$useState2[1];

  React.useEffect(function () {
    if (aweUtils.isArray(data)) {
      var item = data[0];
      if (!item) return;
      var newKeys = Object.keys(data[0]).filter(function (item) {
        return item !== 'x' && item !== 'key' && item !== 'outliers';
      });
      var newData = [];
      data.map(function (row, index) {
        var newRow = {};
        newKeys.forEach(function (item) {
          newRow = {};
          newRow["x"] = row["x"];
          newRow["key"] = row["key"];
          newRow["value"] = row[item];
          newData.push(newRow);
        });
        return index;
      });
      var dv = new dataSet.DataView();
      dv.source(newData).transform({
        type: 'bin.quantile',
        field: 'value',
        as: 'bin',
        groupBy: ['x', 'key']
      });
      setChartData(dv);
    }
  }, [props.data]);
  return React.createElement("div", {
    className: classNames(className, _defineProperty({}, "".concat(prefixCls$4), true)),
    style: style
  }, title && React.createElement("h4", null, title), React.createElement(bizcharts.Chart, {
    height: height,
    data: chartData,
    scale: cols,
    padding: padding,
    forceFit: true
  }, React.createElement(bizcharts.Axis, Object.assign({
    key: "axis-x",
    name: "x"
  }, xAxis)), React.createElement(bizcharts.Axis, Object.assign({
    key: "axis-y",
    name: "value"
  }, yAxis)), React.createElement(bizcharts.Tooltip, Object.assign({}, tooltip)), React.createElement(bizcharts.Legend, Object.assign({}, legend)), React.createElement(bizcharts.Geom, {
    type: "schema",
    position: "key*bin",
    size: borderWidth,
    color: ['x', function (val) {
      return colorMap[val];
    }],
    style: ['x', {
      stroke: 'rgba(0, 0, 0, 0.45)',
      fill: function fill(val) {
        return colorMap[val];
      },
      fillOpacity: 0.3
    }],
    shape: "box",
    adjust: "dodge"
  }), outliersFlag ? React.createElement(bizcharts.View, {
    data: data
  }, React.createElement(bizcharts.Geom, {
    type: 'point',
    position: 'key*outliers',
    shape: "circle",
    color: ['x', outlierColor],
    size: 3,
    active: false,
    adjust: "dodge"
  })) : ''));
};

BoxChart.defaultProps = {
  data: [],
  height: 400,
  colors: [],
  borderWidth: 20,
  valueSection: [],
  outlierColor: [],
  xAxis: {},
  yAxis: {},
  legend: {},
  tooltip: {},
  padding: 'auto'
};

exports.Area = AreaChart;
exports.Bar = BarChart;
exports.Box = BoxChart;
exports.Calendar = Calendar;
exports.Line = LineChart;
exports.Pie = PieChart;
exports.Radar = RadarChart;
