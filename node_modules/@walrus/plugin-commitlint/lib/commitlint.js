"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = commitLint;

var _sharedUtils = require("@walrus/shared-utils");

var _defaultConfig = _interopRequireDefault(require("./defaultConfig"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const load = require('@commitlint/load');

const read = require('@commitlint/read');

const lint = require('@commitlint/lint');

const stdin = require('get-stdin');

const pkg = require('../package.json');

function commitLint() {
  return _commitLint.apply(this, arguments);
}

function _commitLint() {
  _commitLint = _asyncToGenerator(function* (raw = [], config = {}) {
    const options = Object.assign({}, _defaultConfig.default, config);

    if (options.env) {
      if (!(options.env in process.env)) {
        throw new Error(`Recieved '${options.env}' as value for --env, but environment variable '${options.env}' is not available globally`);
      }

      options.edit = process.env[options.env];
    }

    const fromStdin = (0, _utils.checkFromStdin)(raw, options);

    const range = _sharedUtils._.pick(options, 'edit', 'from', 'to');

    const input = yield fromStdin ? stdin() : read(range, {
      cwd: options.cwd
    });
    const messages = (Array.isArray(input) ? input : [input]).filter(message => typeof message === 'string').filter(message => message.trim() !== '').filter(Boolean);

    if (messages.length === 0 && !(0, _utils.checkFromRepository)(options)) {
      const err = new Error('[input] is required: supply via stdin, or --env or --edit or --from and --to');
      console.log(err.message);
      throw err;
    }

    const loadOpts = {
      cwd: options.cwd,
      file: options.config
    };
    const loaded = yield load((0, _utils.getSeed)(options), loadOpts);
    const parserOpts = (0, _utils.selectParserOpts)(loaded.parserPreset);
    const opts = {
      parserOpts: {},
      plugins: {},
      ignores: [],
      defaultIgnores: true
    };

    if (parserOpts) {
      opts.parserOpts = parserOpts;
    }

    if (loaded.plugins) {
      opts.plugins = loaded.plugins;
    }

    if (loaded.ignores) {
      opts.ignores = loaded.ignores;
    }

    if (loaded.defaultIgnores === false) {
      opts.defaultIgnores = false;
    }

    const format = (0, _utils.loadFormatter)(loaded, options); // Strip comments if reading from `.git/COMMIT_EDIT_MSG`

    if (range.edit) {
      opts.parserOpts['commentChar'] = '#';
    }

    const lints = messages.map(message => lint(message, loaded.rules, opts)); // @ts-ignore

    const results = yield Promise.all(lints);
    const report = results.reduce((info, result) => {
      info.valid = result.valid ? info.valid : false;
      info.errorCount += result.errors.length;
      info.warningCount += result.warnings.length;
      info.results.push(result);
      return info;
    }, {
      valid: true,
      errorCount: 0,
      warningCount: 0,
      results: []
    });
    const output = format(report, {
      color: options.color,
      verbose: options.verbose,
      helpUrl: options.helpUrl ? options.helpUrl.trim() : 'https://github.com/conventional-changelog/commitlint/#what-is-commitlint'
    });

    if (!output.quiet && output !== '') {
      console.log(output);
    }

    if (!report.valid) {
      const err = new Error(output);
      err['type'] = pkg.name;
      throw err;
    }
  });
  return _commitLint.apply(this, arguments);
}