"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var getStdin = _interopRequireWildcard(require("get-stdin"));

var _sharedUtils = require("@walrus/shared-utils");

var _linter = _interopRequireDefault(require("./linter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const rawArgv = process.argv.slice(2);

function Cli(opts) {
  const linter = new _linter.default(opts);
  opts = Object.assign({
    cmd: 'walrus-engine',
    tagline: 'JavaScript Custom Style',
    version: '0.0.0'
  }, opts);
  const argv = (0, _sharedUtils.minimist)(rawArgv, {
    alias: {
      global: 'globals',
      plugin: 'plugins',
      env: 'envs',
      help: 'h',
      verbose: 'v'
    },
    boolean: ['fix', 'help', 'stdin', 'verbose', 'version'],
    string: ['global', 'plugin', 'parser', 'env']
  });
  const lintOpts = {
    fix: argv.fix,
    globals: argv.global,
    plugins: argv.plugin,
    envs: argv.env,
    parser: argv.parser
  };
  let stdinText;

  if (argv.stdin) {
    getStdin().then(function (text) {
      stdinText = text;
      linter.lintText(text, lintOpts, onResult);
    });
  } else {
    const files = argv._;
    files.shift();
    linter.lintFiles(files, lintOpts, onResult);
  }

  function onResult(err, result) {
    if (err) return onError(err);

    if (argv.stdin && argv.fix) {
      if (result.results[0].output) {
        // Code contained fixable errors, so print the fixed code
        process.stdout.write(result.results[0].output);
      } else {
        // Code did not contain fixable errors, so print original code
        process.stdout.write(stdinText);
      }
    }

    if (!result.errorCount && !result.warningCount) {
      process.exitCode = 0;
      return;
    }

    console.error('%s: %s', opts.cmd, opts.tagline);
    const isFixable = result.results.some(function (result) {
      return result.messages.some(function (message) {
        return !!message.fix;
      });
    });

    if (isFixable) {
      console.error('%s: %s', opts.cmd, 'Run `' + opts.cmd + ' --fix` to automatically fix some problems.');
    }

    result.results.forEach(function (result) {
      result.messages.forEach(function (message) {
        log('  %s:%d:%d: %s%s', result.filePath, message.line || 0, message.column || 0, message.message, argv.verbose ? ' (' + message.ruleId + ')' : '');
      });
    });
    process.exitCode = result.errorCount ? 1 : 0;
  }

  function onError(err) {
    console.error(opts.cmd + ': Unexpected linter output:\n');
    console.error(err.stack || err.message || err);
    console.error('\nIf you think this is a bug in `%s`, open an issue: %s', opts.cmd, opts.bugs);
    process.exitCode = 1;
  }

  function log(template, filePath, line, column, message, ruleId) {
    if (argv.stdin && argv.fix) {
      arguments[0] = opts.cmd + ': ' + arguments[0];
      console.error.apply(console, arguments);
    } else {
      console.log.apply(console, arguments);
    }
  }
}

var _default = Cli;
exports.default = _default;