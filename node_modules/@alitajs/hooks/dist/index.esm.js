import { useState, useCallback, useRef, useEffect, useLayoutEffect } from 'react';
import debounce from 'lodash/debounce';
import screenFull from 'screenfull';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var useToggle = function useToggle(initialValue) {
  var _useState = useState(initialValue),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var toggle = useCallback(function (nextValue) {
    if (typeof nextValue === 'boolean') {
      setValue(nextValue);
    } else {
      setValue(function (currentValue) {
        return !currentValue;
      });
    }
  }, [setValue]);
  return [value, toggle];
};

var useModal = function useModal() {
  var _useToggle = useToggle(false),
      _useToggle2 = _slicedToArray(_useToggle, 2),
      on = _useToggle2[0],
      toggle = _useToggle2[1];

  var _useState = useState(),
      _useState2 = _slicedToArray(_useState, 2),
      initValue = _useState2[0],
      setInitValue = _useState2[1];

  var openModal = function openModal(initValue) {
    toggle(true);
    setInitValue(initValue);
  };

  var closeModal = function closeModal() {
    toggle(false);
  };

  return {
    initValue: initValue,
    openModal: openModal,
    visible: on,
    closeModal: closeModal
  };
};

var isClient = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object';

var useWindowSize = function useWindowSize() {
  var waitTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;
  var initialWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  var initialHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  var frame = useRef(0);

  var _useState = useState({
    width: isClient ? window.innerWidth : initialWidth,
    height: isClient ? window.innerHeight : initialHeight
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  useEffect(function () {
    if (isClient) {
      var handler = function handler() {
        cancelAnimationFrame(frame.current);
        frame.current = requestAnimationFrame(function () {
          setState({
            width: window.innerWidth,
            height: window.innerHeight
          });
        });
      };

      var handleResize = debounce(function () {
        handler();
      }, waitTime);
      window.addEventListener('resize', handler);
      return function () {
        cancelAnimationFrame(frame.current);
        window.removeEventListener('resize', handleResize);
      };
    } else {
      return undefined;
    }
  }, []);
  return state;
};

var noop = function noop() {};

var useFullScreen = function useFullScreen(sourceRef, on) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var video = options.video,
      _options$onClose = options.onClose,
      onClose = _options$onClose === void 0 ? noop : _options$onClose;

  var _useState = useState(on),
      _useState2 = _slicedToArray(_useState, 2),
      isFullScreen = _useState2[0],
      setIsFullScreen = _useState2[1];

  var _useState3 = useState(sourceRef),
      _useState4 = _slicedToArray(_useState3, 2),
      ref = _useState4[0],
      setRef = _useState4[1];

  useEffect(function () {
    if (ref) {
      setRef(ref);
    } else {
      setRef({
        current: document.documentElement
      });
    }
  }, [sourceRef]);
  useLayoutEffect(function () {
    if (!on) {
      return;
    }

    if (!ref.current) {
      return;
    }

    var onWebkitEndFullScreen = function onWebkitEndFullScreen() {
      video.current.removeEventListener('webkitendfullscreen', onWebkitEndFullScreen);
      onClose();
    };

    var onChange = function onChange() {
      if (screenFull.isEnabled) {
        var isScreenFullFullScreen = screenFull.isFullscreen;
        setIsFullScreen(isScreenFullFullScreen);

        if (!isScreenFullFullScreen) {
          onClose();
        }
      }
    };

    if (screenFull.isEnabled) {
      try {
        screenFull.request(ref.current);
        setIsFullScreen(true);
      } catch (error) {
        onClose(error);
        setIsFullScreen(false);
      }

      screenFull.on('change', onChange);
    } else if (video && video.current && video.current.webkitEnterFullscreen) {
      video.current.webkitEnterFullscreen();
      video.current.addEventListener('webkitendfullscreen', onWebkitEndFullScreen);
      setIsFullScreen(true);
    } else {
      onClose();
      setIsFullScreen(false);
    }

    return function () {
      setIsFullScreen(false);

      if (screenFull.isEnabled) {
        try {
          screenFull.off('change', onChange);
          screenFull.exit();
        } catch (_unused) {}
      } else if (video && video.current && video.current.webkitExitFullscreen) {
        video.current.removeEventListener('webkitendfullscreen', onWebkitEndFullScreen);
        video.current.webkitExitFullscreen();
      }
    };
  }, [on, video, ref]);
  return isFullScreen;
};

export { useFullScreen, useModal, useToggle, useWindowSize };
